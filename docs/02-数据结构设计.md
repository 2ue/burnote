# Enclosed 改造方案 - 数据结构设计

## 一、数据库Schema设计

### 1.1 现有Schema

**文件**: `packages/app-server/src/modules/notes/notes.types.ts`

```typescript
// 当前的DatabaseNote类型
interface DatabaseNote {
  payload: string;              // 加密的内容
  deleteAfterReading: boolean;  // 阅后即焚标志
  expirationDate?: string;      // 过期时间(ISO 8601)
  encryptionAlgorithm: string;  // 加密算法
  serializationFormat: string;  // 序列化格式
  isPublic: boolean;            // 公开标志(目前未使用)
}
```

### 1.2 扩展Schema

```typescript
// 新的DatabaseNote类型
interface DatabaseNote {
  // === 原有字段(不变) ===
  payload: string;
  deleteAfterReading: boolean;
  expirationDate?: string;
  encryptionAlgorithm: string;
  serializationFormat: string;
  isPublic: boolean;

  // === 新增字段 ===
  createdBy?: string;           // 创建者用户ID(可选,匿名时为null)
  createdAt: string;            // 创建时间(ISO 8601格式)
  encTitle?: string;            // 加密的标题(可选)
  viewCount?: number;           // 被查看次数(可选)
}
```

### 1.3 字段说明

| 字段 | 类型 | 必填 | 说明 |
|------|------|------|------|
| `createdBy` | string | ❌ | 用户ID。如果用户登录时创建,存用户ID;如果匿名,为null |
| `createdAt` | string | ✅ | 创建时间,格式: `2025-10-17T08:00:00.000Z` |
| `encTitle` | string | ❌ | 加密的标题。使用与payload相同的密钥加密 |
| `viewCount` | number | ❌ | 被查看的次数。每次GET时+1 |

---

## 二、LocalStorage数据结构

### 2.1 存储Key

```typescript
const STORAGE_KEY = 'enclosed_my_notes';
const STORAGE_VERSION = '1.0.0';
```

### 2.2 数据结构

```typescript
interface LocalStorageData {
  version: string;              // 数据版本,用于未来迁移
  notes: LocalNoteRecord[];     // notes列表
}

interface LocalNoteRecord {
  noteId: string;               // note ID
  url: string;                  // 完整URL(含hash fragment的key)
  title?: string;               // 用户输入的标题(明文)
  createdAt: string;            // 创建时间(ISO 8601)
  expiresAt?: string;           // 过期时间(ISO 8601,可选)
  deleteAfterReading: boolean;  // 是否阅后即焚
  isPasswordProtected: boolean; // 是否有密码保护
  status?: 'active' | 'expired' | 'destroyed'; // 状态(客户端计算)
}
```

### 2.3 示例数据

```json
{
  "version": "1.0.0",
  "notes": [
    {
      "noteId": "abc123xyz",
      "url": "http://localhost:8787/abc123xyz#key=base64EncodedKey&pwd=1",
      "title": "API密钥分享",
      "createdAt": "2025-10-17T08:00:00.000Z",
      "expiresAt": "2025-10-17T09:00:00.000Z",
      "deleteAfterReading": false,
      "isPasswordProtected": true,
      "status": "active"
    },
    {
      "noteId": "def456uvw",
      "url": "http://localhost:8787/def456uvw#key=anotherKey",
      "title": "临时文档",
      "createdAt": "2025-10-16T10:00:00.000Z",
      "deleteAfterReading": true,
      "isPasswordProtected": false,
      "status": "destroyed"
    }
  ]
}
```

---

## 三、API数据模型

### 3.1 NoteMetadata (客户端 ↔ 服务器)

```typescript
// GET /api/notes/:noteId/metadata 响应
interface NoteMetadata {
  noteId: string;
  createdAt: string;
  expiresAt?: string;
  deleteAfterReading: boolean;
  isPasswordProtected: boolean;
  viewCount: number;
  status: 'active' | 'expired' | 'destroyed';
}

// GET /api/users/me/notes 响应
interface UserNotesListResponse {
  notes: NoteMetadataListItem[];
  total: number;
}

interface NoteMetadataListItem {
  noteId: string;
  encTitle?: string;        // 加密的标题
  createdAt: string;
  expiresAt?: string;
  deleteAfterReading: boolean;
  isPasswordProtected: boolean;
  viewCount: number;
}
```

### 3.2 创建Note请求扩展

```typescript
// POST /api/notes 请求body扩展
interface CreateNoteRequest {
  // === 原有字段 ===
  payload: string;
  deleteAfterReading: boolean;
  ttlInSeconds?: number;
  encryptionAlgorithm: string;
  serializationFormat: string;
  isPublic: boolean;

  // === 新增字段 ===
  encTitle?: string;        // 加密的标题(可选)
  linkToUser?: boolean;     // 是否关联到当前用户(默认true)
}
```

---

## 四、数据流转图

### 4.1 创建Note数据流

```
┌──────────────────────────────────────────────────┐
│ 1. 用户输入                                       │
│    - content: "My secret text"                   │
│    - title: "API Key"                            │
│    - password: "pass123"                         │
└──────────────┬───────────────────────────────────┘
               │
               ▼
┌──────────────────────────────────────────────────┐
│ 2. 客户端加密 (packages/app-client)              │
│    - baseKey = generateBaseKey()                 │
│    - encryptedContent = encrypt(content, baseKey)│
│    - encryptedTitle = encrypt(title, baseKey)    │
└──────────────┬───────────────────────────────────┘
               │
               ▼
┌──────────────────────────────────────────────────┐
│ 3. 发送到服务器                                   │
│    POST /api/notes                               │
│    {                                             │
│      payload: "加密后的内容",                     │
│      encTitle: "加密后的标题",                    │
│      linkToUser: true                            │
│    }                                             │
└──────────────┬───────────────────────────────────┘
               │
               ▼
┌──────────────────────────────────────────────────┐
│ 4. 服务器存储 (packages/app-server)              │
│    Unstorage.setItem(noteId, {                   │
│      payload: "加密后的内容",                     │
│      encTitle: "加密后的标题",                    │
│      createdBy: userId,  // 如果有登录           │
│      createdAt: now()                            │
│    })                                            │
└──────────────┬───────────────────────────────────┘
               │
               ▼
┌──────────────────────────────────────────────────┐
│ 5. 返回noteId并保存到localStorage                │
│    - noteId: "abc123"                            │
│    - url: "http://.../abc123#key=baseKey"        │
│    - localStorage存储明文标题 "API Key"          │
└──────────────────────────────────────────────────┘
```

### 4.2 查看列表数据流

```
┌──────────────────────────────────────────────────┐
│ 1. 用户访问 /my-notes                            │
└──────────────┬───────────────────────────────────┘
               │
               ▼
┌──────────────────────────────────────────────────┐
│ 2. 读取localStorage                              │
│    const data = localStorage.getItem(            │
│      'enclosed_my_notes'                         │
│    )                                             │
└──────────────┬───────────────────────────────────┘
               │
               ▼
┌──────────────────────────────────────────────────┐
│ 3. 计算状态并渲染                                 │
│    notes.map(note => ({                          │
│      ...note,                                    │
│      status: calculateStatus(note)  // 客户端计算 │
│    }))                                           │
└──────────────┬───────────────────────────────────┘
               │
               ▼
┌──────────────────────────────────────────────────┐
│ 4. (可选)从服务器同步metadata                     │
│    GET /api/users/me/notes                       │
│    - 更新viewCount                               │
│    - 确认note是否仍存在                          │
└──────────────────────────────────────────────────┘
```

---

## 五、存储后端兼容性

### 5.1 Unstorage (当前)

**问题**: Unstorage是KV存储,不支持复杂查询

**影响**: 无法高效实现 `getNotesByUserId()`

**解决方案**:

#### 方案1: 内存索引(推荐)

在服务器启动时,加载所有noteId并建立索引:

```typescript
// packages/app-server/src/modules/notes/notes.repository.ts

// 内存索引: userId -> noteId[]
const userNotesIndex = new Map<string, Set<string>>();

async function saveNote({ userId, ...data }) {
  const noteId = generateId();

  // 存储note
  await storage.setItem(noteId, { ...data, createdBy: userId });

  // 更新索引
  if (userId) {
    if (!userNotesIndex.has(userId)) {
      userNotesIndex.set(userId, new Set());
    }
    userNotesIndex.get(userId)!.add(noteId);
  }

  return { noteId };
}

async function getNotesByUserId({ userId }) {
  const noteIds = userNotesIndex.get(userId) || new Set();
  const notes = await Promise.all(
    Array.from(noteIds).map(id => storage.getItem(id))
  );
  return notes.filter(n => n !== null);
}
```

**优点**: 简单,不需要修改存储后端
**缺点**: 服务器重启后需要重建索引(启动时扫描所有keys)

#### 方案2: 切换到SQLite

如果notes数量很大(>10000),可以切换到SQLite:

```typescript
// 使用 unstorage/drivers/fs-lite 或直接用 better-sqlite3
import Database from 'better-sqlite3';

const db = new Database('notes.db');

db.exec(`
  CREATE TABLE IF NOT EXISTS notes (
    note_id TEXT PRIMARY KEY,
    payload TEXT NOT NULL,
    enc_title TEXT,
    created_by TEXT,
    created_at TEXT NOT NULL,
    expires_at TEXT,
    delete_after_reading INTEGER,
    ...
  );

  CREATE INDEX idx_created_by ON notes(created_by);
  CREATE INDEX idx_created_at ON notes(created_at);
`);
```

**优点**: 支持复杂查询,性能好
**缺点**: 增加依赖,不支持Cloudflare Workers

---

## 六、数据迁移策略

### 6.1 现有数据迁移

对于已存在的notes,添加默认值:

```typescript
// packages/app-server/src/modules/notes/notes.repository.ts

async function migrateExistingNotes() {
  const noteIds = await storage.getKeys();

  for (const noteId of noteIds) {
    const note = await storage.getItem(noteId);

    if (!note.createdAt) {
      // 添加默认创建时间
      note.createdAt = new Date().toISOString();
      await storage.setItem(noteId, note);
    }
  }
}
```

### 6.2 LocalStorage版本迁移

```typescript
// packages/app-client/src/modules/notes/notes.services.ts

function migrateLocalStorage() {
  const raw = localStorage.getItem('enclosed_my_notes');
  if (!raw) return;

  const data = JSON.parse(raw);

  // 如果是旧版本(没有version字段)
  if (!data.version) {
    const migrated = {
      version: '1.0.0',
      notes: Array.isArray(data) ? data : []
    };
    localStorage.setItem('enclosed_my_notes', JSON.stringify(migrated));
  }
}
```

---

## 七、数据容量规划

### 7.1 LocalStorage容量

**浏览器限制**: 约5-10MB (因浏览器而异)

**单条记录大小**:
```
noteId: 50 bytes
url: 200 bytes (含完整key)
title: 100 bytes
其他字段: 150 bytes
─────────────────
总计: ~500 bytes
```

**最大容量**: 5MB / 500 bytes = **约10,000条记录**

**建议**:
- 默认只保留最近1000条
- 提供"归档"功能,导出旧记录
- 定期清理已过期的记录

### 7.2 服务器存储

**单个note大小**: 假设平均50KB (含加密payload)

**1000个notes**: 50MB
**10000个notes**: 500MB
**100000个notes**: 5GB

**建议**:
- 设置用户配额(如每用户最多1000个active notes)
- 定期清理过期notes
- 考虑使用对象存储(S3/R2)存储大文件

---

## 八、数据一致性

### 8.1 LocalStorage vs 服务器不一致

**场景1**: LocalStorage有记录,但服务器已删除

**检测**:
```typescript
async function syncWithServer(localNotes: LocalNoteRecord[]) {
  const results = await Promise.all(
    localNotes.map(note =>
      fetch(`/api/notes/${note.noteId}/exists`)
        .then(r => r.json())
    )
  );

  // 移除服务器不存在的记录
  const validNotes = localNotes.filter((note, i) =>
    results[i].noteExists
  );

  saveToLocalStorage(validNotes);
}
```

**场景2**: 服务器有记录,但LocalStorage没有

**解决**: 提供"从服务器恢复"按钮

```typescript
async function restoreFromServer() {
  const response = await fetch('/api/users/me/notes');
  const { notes } = await response.json();

  // 合并到localStorage(去重)
  const local = loadFromLocalStorage();
  const merged = mergeLists(local, notes);
  saveToLocalStorage(merged);
}
```

---

**下一步**: 阅读 [03-API设计.md](./03-API设计.md)
