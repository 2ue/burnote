# Enclosed 改造方案 - 风险评估

## 【Linus的最后警告】

> "我告诉过你这是个坏主意。但如果你坚持,至少要知道自己在放弃什么。"
>
> **Enclosed的核心价值是零知识加密。这个改造会降低隐私保护。**
>
> 不是说不能做,而是要**清楚代价**。

---

## 一、隐私风险分析

### 1.1 原版Enclosed的隐私保证

| 保证 | 说明 |
|------|------|
| 服务器零知识 | 服务器永远看不到note内容 |
| 完全匿名 | 服务器不知道是谁创建的note |
| 无追踪 | 无法关联用户和他们的notes |
| 抗强制披露 | 即使服务器被入侵,攻击者也无法解密 |

### 1.2 改造后失去的保证

| 损失 | 影响 | 严重程度 |
|------|------|----------|
| **服务器知道用户创建了哪些note** | 可以追踪用户活动 | 🔴 高 |
| **可以被迫交出用户的note列表** | 执法部门可以获取用户创建记录 | 🔴 高 |
| **用户行为模式可被分析** | 创建频率、时间等模式可见 | ⚠️ 中 |

### 1.3 仍然保留的保证

| 保证 | 说明 |
|------|------|
| ✅ 内容仍加密 | 服务器仍然看不到note内容 |
| ✅ 标题加密(如果实现) | 服务器看不到标题明文 |
| ✅ 密码保护 | note的密码仍然不会发送到服务器 |
| ✅ 可选匿名 | 用户可以选择不关联账户 |

---

## 二、技术风险

### 2.1 存储后端限制

**风险**: Unstorage(KV存储)不支持复杂查询

**影响**:
- 无法高效实现 `getNotesByUserId()`
- 需要扫描所有keys或维护内存索引
- 性能随notes数量线性下降

**概率**: 🔴 100% (这是KV存储的本质限制)

**缓解措施**:
1. **内存索引** - 在服务器启动时加载
   - 优点: 简单,不需要改存储
   - 缺点: 服务器重启需要重建,内存占用
2. **切换到SQLite** - 支持查询的关系数据库
   - 优点: 查询高效,支持复杂过滤
   - 缺点: 不支持Cloudflare Workers,需要额外维护
3. **二级索引** - 单独存储userId->noteIds映射
   - 优点: 兼容所有存储后端
   - 缺点: 需要维护一致性

**推荐**: 先用内存索引,notes数量超过10000时切换SQLite

---

### 2.2 LocalStorage容量限制

**风险**: 浏览器localStorage容量限制(约5-10MB)

**影响**:
- 单用户最多存储约10000条记录
- 超限后无法添加新记录
- 用户可能不知道已满

**概率**: ⚠️ 中等 (活跃用户1年内可能达到)

**缓解措施**:
1. **定期清理** - 自动删除已过期记录
2. **归档功能** - 导出旧记录到JSON文件
3. **分页加载** - 不要一次性加载所有记录
4. **容量告警** - 当使用率>80%时提示用户

**代码示例**:
```typescript
function checkLocalStorageCapacity(): number {
  let total = 0;
  for (let key in localStorage) {
    if (localStorage.hasOwnProperty(key)) {
      total += localStorage[key].length;
    }
  }
  return total; // 返回字节数
}

function getUsagePercentage(): number {
  const used = checkLocalStorageCapacity();
  const limit = 5 * 1024 * 1024; // 假设5MB限制
  return (used / limit) * 100;
}
```

---

### 2.3 跨设备同步问题

**风险**: LocalStorage不跨设备同步

**影响**:
- 用户在不同设备上看到不同的列表
- 手机创建的note,电脑上看不到
- 容易造成困惑

**概率**: 🔴 100% (LocalStorage本质限制)

**缓解措施**:
1. **服务器端存储**(需要用户登录)
   - 从服务器API获取完整列表
   - 合并到LocalStorage
2. **明确告知用户**
   - 文档中说明LocalStorage的限制
   - UI上提示"此列表仅存储在本设备"
3. **提供导出/导入功能**
   - 用户可以手动导出JSON
   - 在另一设备导入

**UI提示示例**:
```tsx
<Alert variant="info">
  <AlertDescription>
    📱 此列表存储在您的浏览器中,不会自动同步到其他设备。
    如需跨设备访问,请使用"导出"和"导入"功能。
  </AlertDescription>
</Alert>
```

---

### 2.4 数据一致性问题

**风险**: LocalStorage和服务器数据不一致

**场景**:
1. LocalStorage有记录,但服务器已删除
2. 服务器有记录,但LocalStorage没有(换设备/清除数据)
3. 其他用户删除了note,但LocalStorage仍显示

**概率**: ⚠️ 中等 (正常使用会遇到)

**影响**:
- 用户看到"已删除"的note
- 点击后显示404错误
- 造成困惑

**缓解措施**:
1. **同步按钮**
   ```tsx
   <Button onClick={syncWithServer}>
     <div class="i-tabler-refresh"></div>
     同步
   </Button>
   ```
2. **懒检测** - 用户访问note时检测
   ```typescript
   async function checkNoteExists(noteId: string): Promise<boolean> {
     try {
       const res = await fetch(`/api/notes/${noteId}/exists`);
       const { noteExists } = await res.json();
       if (!noteExists) {
         removeNote(noteId); // 从LocalStorage删除
       }
       return noteExists;
     } catch {
       return false;
     }
   }
   ```
3. **批量验证** - 页面加载时验证前50条
   ```typescript
   async function validateNotes() {
     const notes = loadNotes().slice(0, 50);
     const results = await Promise.all(
       notes.map(n => fetch(`/api/notes/${n.noteId}/exists`))
     );
     // 删除不存在的
   }
   ```

---

## 三、安全风险

### 3.1 CSRF攻击

**风险**: 删除API可能受到CSRF攻击

**场景**:
```html
<!-- 恶意网站 -->
<form action="http://your-enclosed.com/api/notes/abc123" method="DELETE">
  <button>点击领取奖品</button>
</form>
```

**概率**: ⚠️ 中等 (需要用户访问恶意网站)

**影响**: 用户的notes被删除

**缓解措施**:
1. **CSRF Token** - Enclosed已有CORS中间件,但需要验证
2. **SameSite Cookie** - 设置 `SameSite=Strict`
3. **验证Origin Header**

**实现**:
```typescript
// packages/app-server/src/modules/app/middlewares/cors.middleware.ts
app.use(async (context, next) => {
  const origin = context.req.header('origin');
  const allowedOrigins = config.server.corsOrigins;

  if (origin && !allowedOrigins.includes(origin)) {
    return context.json({ error: 'Forbidden' }, 403);
  }

  await next();
});
```

---

### 3.2 授权绕过

**风险**: 用户A可以删除用户B的note

**场景**: API未正确验证所有权

**概率**: 🔴 高 (如果实现不当)

**影响**: 严重的安全漏洞

**缓解措施**:
```typescript
// 每次删除操作都必须验证
const { note } = await getNoteById({ noteId });

if (note.createdBy && note.createdBy !== userId) {
  throw createForbiddenError();
}

// 且要注意: 如果note.createdBy为null(匿名创建),任何人都能删除
// 这是设计trade-off
```

---

### 3.3 枚举攻击

**风险**: 攻击者可以枚举所有noteIds

**场景**:
```bash
for id in {aaa..zzz}; do
  curl -X GET "http://your-enclosed.com/api/notes/$id/exists"
done
```

**概率**: ⚠️ 中等

**影响**: 攻击者知道哪些noteIds存在(但仍无法解密内容)

**缓解措施**:
1. **Rate Limiting** - 限制API调用频率
2. **使用ULID** - Enclosed已使用,ID空间足够大(2^128)
3. **需要认证** - `/exists` API要求登录

---

## 四、性能风险

### 4.1 大量notes查询慢

**风险**: 用户有10000+ notes时,列表加载缓慢

**影响**: 用户体验差,服务器负载高

**缓解措施**:
1. **分页** - 每次只加载50条
2. **索引** - 在createdAt上建立索引
3. **缓存** - 使用Redis缓存热数据
4. **虚拟滚动** - 前端使用virtual list

---

### 4.2 服务器启动慢

**风险**: 如果使用内存索引,服务器启动时需要扫描所有keys

**场景**: 100000个notes,扫描可能需要几秒

**缓解措施**:
1. **异步初始化** - 服务器启动后后台加载索引
2. **持久化索引** - 将索引保存到文件,启动时直接加载
3. **切换到SQLite** - 不需要内存索引

---

## 五、用户体验风险

### 5.1 LocalStorage丢失后用户困惑

**场景**: 用户清除浏览器数据,打开列表页发现空空如也

**影响**: 用户以为notes被删除了(实际上还在服务器)

**缓解措施**:
1. **明确提示**:
   ```tsx
   <Alert>
     列表为空? 如果您清除了浏览器数据,
     <Button onClick={restoreFromServer}>点此从服务器恢复</Button>
   </Alert>
   ```
2. **自动检测** - 如果用户登录但列表为空,询问是否恢复

---

### 5.2 "已销毁"状态的混淆

**场景**: 阅后即焚的note无法判断是否已被查看

**问题**: 列表中显示"已销毁",但实际上可能还没人查看

**缓解措施**:
1. **改为"阅后即焚"状态** - 不说"已销毁"
2. **添加说明** - "此note设置为阅后即焚,一旦被查看将立即删除"

---

## 六、运维风险

### 6.1 数据迁移

**风险**: 现有用户的notes没有 `createdBy` 字段

**影响**: 这些notes无法被关联到用户,无法在列表中显示

**缓解措施**:
1. **提供迁移脚本** - 启动时自动添加默认值
2. **文档说明** - 告知用户旧notes不会出现在列表中

---

### 6.2 存储方案切换

**风险**: 从Unstorage切换到SQLite需要数据迁移

**缓解措施**: 提供迁移工具

---

## 七、法律与合规风险

### 7.1 GDPR合规

**风险**: 欧盟用户的"被遗忘权"

**要求**: 用户要求删除所有数据时,需要删除所有相关notes

**实现**:
```typescript
async function deleteAllUserData(userId: string) {
  const notes = await getNotesByUserId({ userId });
  await Promise.all(
    notes.map(n => deleteNoteById({ noteId: n.noteId }))
  );
  await deleteUser({ userId });
}
```

---

## 八、总体风险评估

### 风险矩阵

| 风险 | 概率 | 影响 | 优先级 | 缓解成本 |
|------|------|------|--------|----------|
| 隐私降低 | 🔴 高 | 🔴 高 | P0 | 无法完全缓解 |
| 存储限制 | 🔴 高 | ⚠️ 中 | P1 | 中等 |
| 跨设备同步 | 🔴 高 | ⚠️ 中 | P1 | 高 |
| CSRF攻击 | ⚠️ 中 | ⚠️ 中 | P1 | 低 |
| 性能问题 | ⚠️ 中 | ⚠️ 中 | P2 | 中等 |

---

## 九、最终建议

### 【Linus的判断】

> "这个改造的代价是**不可逆的**。一旦你关联了userId和noteId,就无法再声称'零知识'。"
>
> **我的建议仍然是: 直接用Snippet Box或QBin**。
>
> 但如果你坚持,至少做到:
> 1. **明确告知用户隐私trade-off**
> 2. **提供匿名创建选项**
> 3. **不要声称这是'零知识'系统**

### 推荐的实施策略

1. **阶段1**: 只实现LocalStorage版本
   - 不改后端,不关联userId
   - 验证用户需求是否真实存在

2. **阶段2**: 如果用户反馈强烈需要跨设备同步
   - 再实现服务器关联
   - 明确告知隐私影响
   - 提供"匿名模式"开关

3. **长期**: 评估是否切换到其他方案
   - 如果用户真的需要完整管理功能
   - 考虑fork一个新项目,不要破坏Enclosed的品牌

---

**最终决定权在你**。我已经告诉你所有风险了。

**下一步**: 回到 [README.md](./README.md) 或开始实现 [05-实现步骤.md](./05-实现步骤.md)
